#' Generates the rapports for tables in the database
#' @param conn       PostgreSQLConnection object (generated by mg::get_connection())'
#' @param db_table   A specification of the table with schema (or a list of tables with schema)
#' @param output_dir Location to place the generated db_rapports
#' @param slice_ts   The timestamp to generate a rapport for (default is current time)
#' @importFrom rlang .data
#' @importFrom magrittr `%>%`
#' @importFrom data.table `%like%`
#' @examples
#' conn <- mg::get_connection()
#'
#' db_tables <- tidyr::unite(mg::get_tables(conn), 'db_table', 'schema', 'table',
#'    sep = '.', na.rm = TRUE)
#'
#' \dontrun{
#' generate_db_rapport(conn, db_tables)
#' }
#'
#' mg::close_connection(conn)
#' @export
generate_db_rapport <- function(conn, db_table, output_dir, slice_ts = NULL) {

  # Turns out knitting with passing parameters just does not work as expected
  # There is some evaluation that occurs differently if the arguments is passed
  # versus coded into the file. I cannot track down the source of this inconsistency..
  # Instead, we must do it ourselves...

  # Find pandoc path
  invisible(rmarkdown::find_pandoc(dir = '/usr/lib/rstudio-server/bin/pandoc'))

  if (!(grepl('^.*\\/$', x = output_dir))) output_dir <- paste0(output_dir, '/')

  dir.create(output_dir, showWarnings = F)

  c(NA_character_, db_table) %>%
    purrr::walk(~ {

      if (is.null(slice_ts)) slice_ts <- lubridate::now()

      output_name <- ifelse(is.na(.x), '0_overview', .x)

      rapport <- paste0(output_dir, output_name, '.md')
      md <- paste("---",
                  paste0("title: '", ifelse(is.na(.x), 'Overview of DB tables', .x), "'"),
                  "author: null",
                  paste("date:", slice_ts),
                  "output:",
                  "  html_document:",
                  "    mathjax: null",
                  "---", "",
                  sep = '\n')

      # Generate plot
      {
        gg_data <- generate_plot_data(conn, .x, slice_ts)

        md <- paste(md,
                    "# Status of updates",
                    "Overview of the latest updates to table (generated from logs). Green points indicate at least one successful update of the table on the given day. If the circle is empty, the update included no new data. If the circle is red, all attempts at parsing the data for the given day failed. If the circle is empty, the update may be ongoing.",
                    '', sep = '\n')

        if(nrow(gg_data) > 0) {

          if (is.na(.x)) { # overview table
            groups <- list('mg tables'  = '^mg\\.',
                           'lpr3 tables' = '^prod\\.lpr3',
                           'cpr3 tables' = '^prod\\.cpr3',
                           'other prod tables' = '^prod\\.(?!(cpr3)|(lpr3))',
                           'other tables' = '^(?!(prod)|(mg))')
          } else {
            groups = list('.')
          }

          for (g_index in seq_along(groups)) {
            if (length(groups) >  1) {
              md <- paste(md,
                          paste0("# ", names(groups)[g_index]),
                          sep = '\n')
            }
            plotname <- paste0(output_dir, output_name, '_', g_index, '.png')
            gg_data_sub <- gg_data %>% dplyr::filter(grepl(!!groups[g_index], db_table, perl = T))
            if(nrow(gg_data_sub) == 0) next
            ggsave(plotname,
                   plot = generate_plot(gg_data_sub, .x, slice_ts),
                   width  = ifelse(is.na(.x), 13, 5),
                   height = ifelse(is.na(.x), max(1, ceiling(gg_data_sub %>% count(db_table) %>% nrow() / 4)) * 2,  2))

             md <- paste(md,
                         paste0('![](', basename(plotname), ')'),
                         ifelse(length(groups) > 1, '\n', ''),
                         sep = '\n')
           }

        } else {
          md <- paste(md,
                      "```{.bg-light}",
                      "## Warning: No recent updates detected",
                      "```",
                      sep = '\n')
        }
      }

      if (!is.na(.x)) {

        # Run tests
        qq <- mg::get_table(conn, .x, slice_ts = paste(as.Date(slice_ts), '09:00:00'), include_slice_info = T)

        character_columns <- utils::head(qq, 0) %>%
          dplyr::collect() %>%
          dplyr::select(where(is.character)) %>%
          colnames()

        no_information_columns <- qq %>%
          dplyr::select(-any_of(c('until_ts'))) %>%
          dplyr::mutate(dplyr::across(.cols = tidyselect::all_of(character_columns),
                                      .fns = ~ ifelse(. == '', NA, .))) %>%
          dplyr::summarize_all(~ all(is.na(.), na.rm = T)) %>%  # Returns true if column has no information
          dplyr::collect() %>%
          tidyr::pivot_longer(tidyselect::everything(), names_to = 'column_name', values_to = 'only_na') %>%
          dplyr::filter(only_na) %>% # Select only columns with only NA values
          dplyr::pull(column_name)


        md <- paste(md,
                    "# Status of data",
                    "Here we run a number of checks on the data. See the output of each test for details...",
                    "",
                    sep = '\n')

        md <- paste(md, test_0(qq, character_columns), sep = '\n')
        md <- paste(md, test_1(qq, character_columns, no_information_columns), sep = '\n')
        md <- paste(md, test_2(qq, character_columns), sep = '\n')
        md <- paste(md, test_3(qq, character_columns, no_information_columns), sep = '\n')
        md <- paste(md, test_4(qq, character_columns, no_information_columns), sep = '\n')
        md <- paste(md, test_5(qq, character_columns, no_information_columns), sep = '\n')
        md <- paste(md, test_6(qq, character_columns), sep = '\n')

      }
      writeLines(md, con=rapport)

      rmarkdown::render(rapport,
                        output_dir = output_dir,
                        output_file = gsub(".md", ".html", basename(rapport)),
                        quiet = TRUE)

      # Clean up
      tibble::tibble(file = dir(output_dir)) %>%
        dplyr::filter(file %like% paste0(output_name)) %>%
        dplyr::mutate(extension = stringr::str_extract(file, pattern = "(?<=\\.)([a-zA-Z]*$)")) %>%
        dplyr::filter(extension != "html") %>%
        purrr::pwalk(~ unlink(paste0(dirname(rapport), "/", ..1)))
    })
}


utils::globalVariables("to_char")
generate_plot_data <- function(conn, db_table, slice_ts) {

  # Check for updates to data:
  db_updates <- mg::get_table(conn, "prod.logs") %>%
    tidyr::replace_na(list(schema = "prod")) %>%
    tidyr::unite("db_table", "schema", "table", sep = ".") %>%
    dplyr::group_by(.data$db_table, as.Date(.data$start_time)) %>%
    dplyr::slice_max(success) %>%
    dplyr::slice_max(n_insertions + n_deactivations, with_ties = F) %>%
    dplyr::ungroup() %>%
    dplyr::mutate(weekday = as.numeric(to_char(.data$start_time, "ID")),
                  week = ceiling((as.Date(.data$start_time) - !!lubridate::floor_date(slice_ts, "week", week_start = 1)) / 7)) %>%
    dplyr::collect()

  # Generate plot
  gg_data <- db_updates %>%
    dplyr::filter(.data$start_time <= slice_ts)

  if (!is.na(db_table)) {
    gg_data <- gg_data %>% dplyr::filter(.data$db_table == !!db_table)
  }

  gg_data <- gg_data %>%
    dplyr::mutate(success = dplyr::case_when(
      .data$success & (.data$n_insertions + .data$n_deactivations) > 0 ~ 1,
      .data$success ~ 0,
      !.data$success & as.Date(.data$start_time) == lubridate::today() ~ -1,
      !.data$success ~ -2,
      TRUE ~ 0)) %>%
    dplyr::filter(.data$week > -3) %>%
    dplyr::mutate(weekday = factor(.data$weekday, levels = 1:7,  labels = c("Mon", "Tue", "Wed", "Thu", "Fri", "Sat", "Sun")),
                  week    = factor(.data$week,    levels = -2:1, labels = c("3 weeks ago", "2 weeks ago", "last week", "this week"))) %>%
    dplyr::mutate(success = factor(.data$success, levels = c(1, 0, -1, -2)))

  return(gg_data)
}

generate_plot <- function(gg_data, db_table, slice_ts) {

  last_update_possible <- gg_data %>%
    dplyr::group_by(db_table) %>%
    dplyr::summarise(weekday = lubridate::wday(max(pmax(slice_ts - lubridate::days(1), .data$start_time)), week_start = 1), .groups = "drop") %>%
    dplyr::filter(.data$weekday < 7)

  g <- ggplot2::ggplot() +
    ggplot2::geom_point(data = gg_data, ggplot2::aes(x = .data$weekday, y = .data$week, colour = .data$success, shape = .data$success, size = .data$success), stroke = 2) +
    ggplot2::ylab("") + ggplot2::xlab("") +
    ggplot2::scale_colour_manual(values = c(`1` = "green3", `0` = "green3", `-1` = "red", `-2` = "red"), name = "", labels = c("success", "success, no updates", "error / not yet complete", "error"), drop = F) +
    ggplot2::scale_shape_manual(values = c(`1` = 16, `0` = 1, `-1` = 1, `-2` = 16), name = "", labels = c("success", "success, no updates", "error / not yet complete", "error"), drop = F) +
    ggplot2::scale_size_manual(values = c(`1` = 4, `0` = 3, `-1` = 3, `-2` = 4), name = "", labels = c("success", "success, no updates", "error / not yet complete", "error"), drop = F) +
    ggplot2::scale_x_discrete(drop = F) +
    ggplot2::theme_light() +
    ggplot2::theme(axis.text.x = ggplot2::element_text(family = "mono"))
  if (nrow(last_update_possible) > 0) g <- g + ggplot2::geom_rect(data = last_update_possible, ggplot2::aes(xmin = .data$weekday + 0.5), xmax = 7.5, ymin = 3.75, ymax = 4.25, alpha = 0.5)
  if (is.na(db_table)) g <- g + ggplot2::facet_wrap(~ db_table, ncol = 4) + ggplot2::theme(strip.text.x = ggplot2::element_text(size = 10, color = "black"), strip.background = ggplot2::element_blank(), axis.text.x = ggplot2::element_text(angle = 90, hjust = 1, vjust = 0.5))
  return(g)
}

test_0 <- function(qq, character_columns) {

  # Test 0 : lapse in information
  if (!mg::is.historical(qq)) {
    result <- NA
  } else {
    no_new_information <- qq %>%
      dplyr::slice_max("from_ts") %>%
      dplyr::select(-.data$until_ts) %>%
      dplyr::mutate(dplyr::across(.cols = tidyselect::all_of(character_columns),
                                  .fns = ~ ifelse(. == "", NA, .))) %>%
      dplyr::summarize_all(~ all(is.na(.), na.rm = T)) %>%  # Returns true if column has no information
      dplyr::collect() %>%
      tidyr::pivot_longer(tidyselect::everything(), names_to = "column_name", values_to = "only_na") %>%
      dplyr::filter(.data$only_na) %>% # Select only columns with only NA values
      dplyr::pull("column_name")

    result = length(no_new_information) == 0
  }

  md <- "Test 0: Columns without information"
  if (is.na(result)) {
    md <- paste(md, "```{.bg-success}",
                "## Skipped:\t Table is not historical",
                "```", sep = "\n")
  } else if (result) {
    md <- paste(md, "```{.bg-success}",
                "## Passed:\t All columns contain information",
                "```", sep = "\n")
  } else if (!result) {
    md <- paste(md, "```{.bg-warning}",
                "## Warning:\t Some columns contain no new information:",
                paste("\t\t", no_new_information, collapse = "\n"),
                "```", sep = "\n")
  } else {
    md <- paste(md, "```{.bg-danger}",
                "## test error",
                "```", sep = "\n")
  }

  return(md)
}

test_1 <- function(qq, character_columns, no_information_columns) {

  # Test 1 : Information
  result = length(no_information_columns) == 0

  md <- "Test 1: Columns without information"
  if (result) {
    md <- paste(md, "```{.bg-success}",
                "## Passed:\t All columns contain information",
                "```", sep = "\n")
  } else if (!result) {
    md <- paste(md, "```{.bg-warning}",
                "## Warning:\t Some columns contain no information:",
                paste("\t\t", no_information_columns, collapse = "\n"),
                "```", sep = "\n")
  } else {
    md <- paste(md, "```{.bg-danger}",
                "## test error",
                "```", sep = "\n")
  }

  return(md)
}

test_2 <- function(qq, character_columns) {

  # Test 2 : Check for date-like columns
  if (length(character_columns) == 0 || !any(grepl("(date)|(dato)|(start)|(slut)", character_columns))) {
    result <- NA
  } else {
    tmp <- qq %>%
      dplyr::select(tidyselect::all_of(character_columns)) %>%
      dplyr::select(tidyselect::matches("(date)|(dato)|(start)|(slut)")) %>%
      utils::head(1000) %>% tibble::as_tibble()

    is.datelike <- function(obj) {
      return(any(c(
        lubridate::is.Date(obj),
        lubridate::is.POSIXct(obj))))
    }

    # Check for date_like columns
    date_like_columns <- tmp %>%
      dplyr::summarise(dplyr::across(.cols = tidyselect::everything(),
                                     .fns = list(datelike = ~ as.character(all(is.datelike(.), na.rm = T)),
                                                 datatype = ~ first(typeof(.))),
                       .names ="{.col}.{.fn}" )) %>%
      dplyr::collect() %>%
      tidyr::pivot_longer(tidyselect::everything(), names_to = c("column_name", "test"), names_sep = "\\.") %>%
      tidyr::pivot_wider(names_from = "test", values_from = "value") %>%
      dplyr::filter(.data$datelike == "TRUE")

    result <- length(date_like_columns)
  }

  md <- "Test 2: Unconverted date(time) columns"
  if (is.na(result)) {
    md <- paste(md, "```{.bg-success}",
                "## Skipped:\t No candidate columns found",
                "```", sep = "\n")
  } else if (result) {
    md <- paste(md, "```{.bg-success}",
                "## Passed:\t All date(time)-like column have date(time) datatype",
                "```", sep = "\n")
  } else if (!result) {
    tmp <- purrr::pwalk(date_like_columns, ~ paste0('\t\tcolumn "', ..1, '" is of type "', ..3, '" instead of date-like'))

    md <- paste(md, "```{.bg-warning}",
                "## Warning:\t Date(time)-like column found, but datatype is not date(time)-like:",
                paste("\t\t", tmp, collapse = "\n"),
                "```", sep = "\n")
  } else {
    md <- paste(md, "```{.bg-danger}",
                "## test error",
                "```", sep = "\n")
  }

  return(md)
}

test_3 <- function(qq, character_columns, no_information_columns) {

  # Test 3 : Look for unconverted columns
  if (length(character_columns) == 0) {
    result <- NA
  } else {
    column_is_numeric <- qq %>%
      dplyr::select(tidyselect::all_of(character_columns)) %>%
      dplyr::summarise(dplyr::across(.cols = tidyselect::everything(),
                                     .fns = ~ all(grepl("(^0$)|(^[1-9]\\d*$)", .), na.rm = T))) %>%
      dplyr::collect() %>%
      tidyr::pivot_longer(tidyselect::everything(), names_to = "column_name", values_to = "is_numeric") %>%
      dplyr::filter(.data$is_numeric) %>% # Select only columns with only NA values
      dplyr::pull("column_name")

    # Remove columns without information
    column_is_numeric <- setdiff(column_is_numeric, no_information_columns)

    result <- length(column_is_numeric) == 0
  }

  md <- "Test 3: Unconverted numerical columns"
  if (is.na(result)) {
    md <- paste(md, "```{.bg-success}",
                "## Skipped:\t No candidate columns found",
                "```", sep = "\n")
  } else if (result) {
    md <- paste(md, "```{.bg-success}",
                "## Passed:\t No character-columns contain numerics",
                "```", sep = "\n")
  } else if (!result) {
    md <- paste(md, "```{.bg-warning}",
                "## Warning:\t Some character-columns contain numerics:",
                paste("\t\t", column_is_numeric, collapse = "\n"),
                "```", sep = "\n")
  } else {
    md <- paste(md, "```{.bg-danger}",
                "## test error",
                "```", sep = "\n")
  }

  return(md)
}

test_4 <- function(qq, character_columns, no_information_columns) {

  # Test 4 :  Look for unconverted columns
  if (length(character_columns) == 0) {
    result <- NA
  } else {
    column_is_logical <- qq %>%
      dplyr::select(tidyselect::all_of(character_columns)) %>%
      dplyr::summarise(dplyr::across(.cols = tidyselect::everything(),
                                     .fns = ~ all(is.na(.) | grepl("(^true$)|(^false$)|(^$)", ., ignore.case = T), na.rm = T))) %>%
      dplyr::collect() %>%
      tidyr::pivot_longer(tidyselect::everything(), names_to = "column_name", values_to = "is_logical") %>%
      dplyr::filter(.data$is_logical) %>% # Select only columns with only NA values
      dplyr::pull("column_name")

    # Remove columns without information
    column_is_logical <- setdiff(column_is_logical, no_information_columns)

    result <- length(column_is_logical) == 0
  }

  md <- "Test 4: Unconverted logical columns"
  if (is.na(result)) {
    md <- paste(md, "```{.bg-success}",
                "## Skipped:\t No candidate columns found",
                "```", sep = "\n")
  } else if (result) {
    md <- paste(md, "```{.bg-success}",
                "## Passed:\t No character-columns contain logicals",
                "```", sep = "\n")
  } else if (!result) {
    md <- paste(md, "```{.bg-warning}",
                "## Warning:\t Some character-columns contain logicals:",
                paste("\t\t", column_is_logical, collapse = "\n"),
                "```", sep = "\n")
  } else {
    md <- paste(md, "```{.bg-danger}",
                "## test error",
                "```", sep = "\n")
  }

  return(md)
}

test_5 <- function(qq, character_columns, no_information_columns) {

  # Test 5 : whitespace
  if (length(character_columns) == 0) {
    result <- NA
  } else {
    # Check for trailing white space
    column_has_whitespace <- qq %>%
      dplyr::select(tidyselect::all_of(character_columns)) %>%
      dplyr::summarise(dplyr::across(.fns = ~ any(str_length(.) > str_length(trimws(.)), na.rm = T))) %>%
      dplyr::collect() %>%
      tidyr::pivot_longer(tidyselect::everything(), names_to = "column_name", values_to = "extra_whitespace") %>%
      dplyr::filter(.data$extra_whitespace) %>% # Select only columns with only NA values
      dplyr::pull("column_name")

    # Remove columns without information
    column_has_whitespace <- setdiff(column_has_whitespace, no_information_columns)

    result <- length(column_has_whitespace) == 0
  }

  md <- "Test 5: Leading/trailing white space"
  if (is.na(result)) {
    md <- paste(md, "```{.bg-success}",
                "## Skipped:\t No candidate columns found",
                "```", sep = "\n")
  } else if (result) {
    md <- paste(md, "```{.bg-success}",
                "## Passed:\t All character-columns have trimmed whitespace",
                "```", sep = "\n")
  } else if (!result) {
    md <- paste(md, "```{.bg-warning}",
                "## Warning:\t Some character-columns have surplus whitespace:",
                paste("\t\t", column_has_whitespace, collapse = "\n"),
                "```", sep = "\n")
  } else {
    md <- paste(md, "```{.bg-danger}",
                "## test error",
                "```", sep = "\n")
  }

  return(md)
}

test_6 <- function(qq, character_columns) {

  # Test 6 : unencrypted cpr
  if (!any(grepl("(^cpr)|(pnr)", colnames(qq)))){
    result <- NA
  } else {
    column_is_unencrypted <- qq %>%
      dplyr::select(tidyselect::matches("(^cpr)|(pnr)")) %>% utils::head(10) %>% tibble::as_tibble() %>%
      dplyr::mutate_all(stringr::str_length) %>%
      dplyr::summarise(dplyr::across(.cols = tidyselect::everything(),
                                     .fns = ~ any(stringr::str_length(.) == 10, na.rm = T))) %>%
      dplyr::collect() %>%
      tidyr::pivot_longer(tidyselect::everything(), names_to = "column_name", values_to = "is_unencrypted") %>%
      dplyr::filter(.data$is_unencrypted) %>% # Select only columns with only NA values
      dplyr::pull("column_name")

    result <- length(column_is_unencrypted) == 0
  }

  md <- "Test 6: Unencrypted cpr-numbers"
  if (is.na(result)) {
    md <- paste(md, "```{.bg-success}",
                "## Skipped:\t No cpr-like columns found",
                "```", sep = "\n")
  } else if (result) {
    md <- paste(md, "```{.bg-success}",
                "## Passed:\t No unencrpyted cpr-like columns found",
                "```", sep = "\n")
  } else if (!result) {
    md <- paste(md, "```{.bg-warning}",
                "## Warning:\t cpr-like name of length 10 found:",
                paste("\t\t", column_is_unencrypted, collapse = "\n"),
                "```", sep = "\n")
  } else {
    md <- paste(md, "```{.bg-danger}",
                "## test error",
                "```", sep = "\n")
  }

  return(md)
}
